tabscript 1.0

import A from 'module'
import {B, C as D} from "module2"
import
	B
	C as D
from "module2"
import * as E from 'module3'

x : number = 3
xx := undefined or string
xx = "test" or undefined
y := "str"

function a||
	return 5

async function a||
	return await 5

function b|arg: any, x: number or something| : number
	return 5

function b|
	arg: any
	x: number or something
| : number
	return 5

function b|
	arg: any
	x: number or something
|
	return 5


if x == 3
	x = 4

if x > 3 x++

if done(a,b) proceed()

if done(a,b)
	proceed()

if done& a b
	proceed()

if (done& a b) proceed()

if done&
	a
	b
;
	proceed()

data ::= [] as any

x2 ::= {3: 4} as any
sta := {a: 1, b: 2, c: {d: 3, [x2]: {f: 4}}}
sto := {
	a: 1
	b: 2, // optional comma
	c: {
		d: 3
		[x2]: {f: 4}
	}
}

type x =
	z: number
	x: (|arg1:number, arg2:string| : number) or string
	g: number or string
	a: |x| : number
	b: |x:number| : void or string
	c: || : void

(data[3]?.test as any)!.a++ + (4 as number)

str : string = "test"

type myFunc = |a: number, b: number| : number or string



arr : number[] or undefined
sa : [number, string] = [3, "test"]

arr?.[1] as number and {test: number}
arr![1]

lala := <T>|| : T
	return {} as T

lala2 := <T>|| {} as T // Should be able to return literal objects

// Signature overloading
function sdf|t: '3' or {x: number}| : void
function sdf|a: number, b: number| : number
function sdf|a: any, b?: any|
	return 123

sdf({x:42})
sdf& {x:42}
sdf& '3'
sdf& 5, 8

select := |t: 'a' or 'b' or 3| 'x'+t
select(3)

lala3 := <T extends Record<string, number>>|x: T| : T
	return {} as T

rest := |...args: number[]|
	return args.reduce(|a, b| a + b)

i :: any = 3
i = i=3, i==4

for x: in arr console.log& x
for x:number or string of arr console.log& x

for i=0 i<10 i++ console.log& i
for i:=0; i<10; i++; console.log& i

abstract class X<T extends Record<number,any>> extends Array<T>
	arg: number
	constructor|...args: T[]| super(...args)
	method|| : void ;
	abstract abstractMethod|| : void
	get length|| : number
		return super.length

interface Something extends X<Record<number, string>>
	a: number
	b: string
	c|| : void

XXXX := class name<S, T>
	constructor|| {} // return a literal object

new XXXX<number,string>()

text := `This ${lala& 2 (3 as number)} ${`works`}`

enum E2
	A
	B = 42
	C

enum E3 {A, B = 42, C}

enum Direction
	Up,
	Down,
	Left,
	Right,

day:number = 1
switch day
	1
		console.log("It is a Monday.")
	0+a() as any
		console.log("It is a Sunday.")
	*: console.log("It's a day")
	2 console.log("It is a Tuesday.")

function templatedFunc<A>||: A or A[]
	return []

// templated args:
templatedFunc<number or string>
templatedFunc<number or string>()
(3+4)<test or sdf>(x)<A>()

// two comparisons:
(3 + 4) < test or sdf > x

test`string ${text as number} ${3 as number}`

test`string`(text as number)

// Binary logic

result := x ~bit_xor y ~bit_and z ~bit_or ~bit_not 123 ~shift_left 2

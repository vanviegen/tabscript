tabscript 1.0

# Markup/UI plugin for TabScript.
# Provides the : syntax for creating UI elements.
#
# Usage in header:
#   tabscript 1.0 plugin=markup.js (ui=UILibrary)
#
# @module plugins/markup

import type {Parser, State, Register, Options, PluginOptions} from "tabscript"

descr := |regexp: RegExp, name: string|
	regexp.toString = || '<' + name + '>'
	return regexp

# Token patterns specific to markup
TAG_LITERAL := descr& /[0-9a-zA-Z_\-]+/y "tag-literal"
TAG_LITERAL_INTERPOLATE := descr& /[0-9a-zA-Z_\-]*\$\{/y "tag-literal"
STRING := descr& /(['"])(?:(?=(\\?))\2.)*?\1/y "string"

# Create the markup plugin parser extensions.
export default function createMarkupPlugin|register: Register, pluginOptions: PluginOptions, globalOptions: Options|
	funcName := pluginOptions.function or "$"

	mode ::= 0 # 0 ready for arg, 1 comma needed, 2 within command string

	toMode := |s: State, target: number| # like state, but 3 now means the same as 2 but a prepended space is needed if appending to a string
		if mode == 0
			if target >= 2
				s.emit(false,  '`')
		else if mode == 1
			if target == 0
				s.emit(false, ',')
			else if target >= 2
				s.emit(false, ',`')
		else if mode == 2
			if target == 0
				s.emit(false, '`,')
			else if target == 1
				s.emit(false, '`')
			else if target == 3
				s.emit(false, ' ')
		mode = Math.min(2, target)


	# Parse markup value (string or interpolated tag literal).
	# Values can be: literals (div, my-tag), interpolated (`${expr}`), or strings ("foo", 'bar').
	parseMarkupValue := |p: Parser, s: State|
		# Try literal/interpolated first (most common case)
		if parseMarkupLiteral& p s false
			return true

		# Try quoted string - need to wrap in template literal syntax for output
		snap := s.snapshot()
		if p.parseBacktickString(s) or s.accept& STRING
			# Flush separator BEFORE emitting the value (insert at correct position)
			tokens := snap.revertOutput()
			toMode& s 0
			s.emit(...tokens)
			toMode& s 1
			return true

		return false

	parseMarkupLiteral := |p: Parser, s: State, tag: boolean|
		if s.peek& TAG_LITERAL_INTERPOLATE
			# Make sure we start a new string
			if !tag
				toMode& s 0
			toMode& s 2
			while s.accept& TAG_LITERAL_INTERPOLATE
				s.must& p.parseExpression(s)
				s.must& s.accept& '}'
			
			s.accept& TAG_LITERAL

			if !tag
				toMode& s 1 # Exit dedicated string
			return true
		
		if s.peek& TAG_LITERAL
			toMode& s (tag ? 3 : 2)
			s.must& s.accept& TAG_LITERAL
			return true

		return false


	# Parse markup syntax: :tagName.class prop=value @handler
	# Output format: ui(`tagName prop=value`,...)
	parseMarkup := |p: Parser, s: State|
		if !s.read& ':'
			return false

		s.emit& funcName + "("

		startLine := s.inLine
		mode = 0

		while s.inLine == startLine
			# Handle class shorthand: .className
			if s.read& '.'
				toMode& s 2
				s.emit& '.'
				s.must& parseMarkupValue& p s
				continue

			# Handle quoted tag name: "custom-element" or `interpolated`
			stringSnap := s.snapshot()
			if s.accept(STRING) or p.parseBacktickString(s)
				# Convert string to hash-prefixed format: "foo" -> #foo
				tokens := stringSnap.revertOutput()
				toMode& s 2 # string mode
				s.emit& '#'
				toMode& s 0 # add the target string as a separate arg
				s.emit(...tokens)
				continue

			# Try to parse a literal/interpolated identifier
			if !parseMarkupLiteral& p s true
				break

			# Determine what follows the identifier
			op := s.read('=') or s.read(':')
			if op
				toMode& s 2
				s.emit& op
				s.must& parseMarkupValue& p s
			else if s.read('~')
				toMode& s 2
				s.emit& '='
				toMode& s 0
				p.parseExpression(s)
				toMode& s 1
			# else: it's a tag name

		# Optional child block
		saved := s.snapshot()
		savedMode := mode
		toMode& s 0 # Insert a comma if needed before the function
		if !s.parseGroup& {jsOpen: 'function(){', jsClose: '}', next: ';', jsNext: null, allowImplicit: true} || s.recoverErrors& || p.parseStatement(s)
			saved.revertOutput() # No child block found, revert output to remove comma
			mode = savedMode
			
		toMode& s 1 # End any open string
		s.emit& false, ")"

		return true

	# Register the markup parser to run right after type declarations are attempted.
	register.after& 'parseTypeDecl' parseMarkup

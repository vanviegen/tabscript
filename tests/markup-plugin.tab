tabscript 1.0

# Markup/UI plugin for TabScript.
# Provides the : syntax for creating UI elements.
#
# Usage:
#   import plugin "markup-plugin.tab"
#   # Then define A function before using markup syntax
#   A := |...args: any[]| ...
#
# @module plugins/markup

import type {Parser, State, Options, PluginOptions} from "tabscript"

# Create the markup plugin parser extensions.
export default function createMarkupPlugin|p: Parser, globalOptions: Options, pluginOptions: PluginOptions|
	# Token patterns specific to markup
	TAG_LITERAL := p.pattern.. /[0-9a-zA-Z_\-]+/ "tag-literal"
	TAG_LITERAL_INTERPOLATE := p.pattern.. /[0-9a-zA-Z_\-]*\$\{/ "tag-literal"
	STRING := p.pattern.. /(['"])(?:(?=(\\?))\2.)*?\1/ "string"

	funcName := pluginOptions.function or "$"

	mode ::= 0 # 0 ready for arg, 1 comma needed, 2 within command string

	toMode := |s: State, target: number| # like state, but 3 now means the same as 2 but a prepended space is needed if appending to a string
		if mode == 0
			if target >= 2
				s.emit(false,  '`')
		else if mode == 1
			if target == 0
				s.emit(false, ',')
			else if target >= 2
				s.emit(false, ',`')
		else if mode == 2
			if target == 0
				s.emit(false, '`,')
			else if target == 1
				s.emit(false, '`')
			else if target == 3
				s.emit(false, ' ')
		mode = Math.min(2, target)


	# Parse markup value (string or interpolated tag literal).
	# Values can be: literals (div, my-tag), interpolated (`${expr}`), or strings ("foo", 'bar').
	parseMarkupValue := |s: State|
		# Try literal/interpolated first (most common case)
		if parseMarkupLiteral.. s false
			return true

		# Try quoted string - need to wrap in template literal syntax for output
		snap := s.snapshot()
		if p.parseBacktickString(s) or s.accept.. STRING
			# Flush separator BEFORE emitting the value (insert at correct position)
			tokens := snap.revertOutput()
			toMode.. s 0
			s.emit(...tokens)
			toMode.. s 1
			return true

		return false

	parseMarkupLiteral := |s: State, tag: boolean|
		if s.peek.. TAG_LITERAL_INTERPOLATE
			# Make sure we start a new string
			if !tag
				toMode.. s 0
			toMode.. s 2
			while s.accept.. TAG_LITERAL_INTERPOLATE
				s.must.. p.parseExpression(s)
				s.must.. s.accept.. '}'
			
			s.accept.. TAG_LITERAL

			if !tag
				toMode.. s 1 # Exit dedicated string
			return true
		
		if s.peek.. TAG_LITERAL
			toMode.. s (tag ? 3 : 2)
			s.must.. s.accept.. TAG_LITERAL
			return true

		return false


	# Parse markup syntax: :tagName.class prop=value @handler
	# Output format: ui(`tagName prop=value`,...)
	parseMarkup := |s: State|
		if !s.read.. ':'
			return false

		s.emit.. funcName + "("

		startLine := s.inLine
		mode = 0

		while s.inLine == startLine
			# Handle class shorthand: .className
			if s.read.. '.'
				toMode.. s 2
				s.emit.. '.'
				s.must.. parseMarkupValue.. s
				continue

			# Handle quoted tag name: "custom-element" or `interpolated`
			stringSnap := s.snapshot()
			if s.accept(STRING) or p.parseBacktickString(s)
				# Convert string to hash-prefixed format: "foo" -> #foo
				tokens := stringSnap.revertOutput()
				toMode.. s 2 # string mode
				s.emit.. '#'
				toMode.. s 0 # add the target string as a separate arg
				s.emit(...tokens)
				continue

			# Try to parse a literal/interpolated identifier
			if !parseMarkupLiteral.. s true
				break

			# Determine what follows the identifier
			op := s.read('=') or s.read(':')
			if op
				toMode.. s 2
				s.emit.. op
				s.must.. parseMarkupValue.. s
			else if s.read('~')
				toMode.. s 2
				s.emit.. '='
				toMode.. s 0
				p.parseExpression(s)
				toMode.. s 1
			# else: it's a tag name

		# Optional child block
		saved := s.snapshot()
		savedMode := mode
		toMode.. s 0 # Insert a comma if needed before the function
		if !s.parseGroup.. {jsOpen: 'function(){', jsClose: '}', next: ';', jsNext: null, allowImplicit: true} || s.recoverErrors.. || p.parseStatement(s)
			saved.revertOutput() # No child block found, revert output to remove comma
			mode = savedMode
			
		toMode.. s 1 # End any open string
		s.emit.. false, ")"

		return true

	# Keep reference to original parseTypeDecl
	origParseTypeDecl := p.parseTypeDecl.bind(p)

	# Replace parseTypeDecl to run markup parser after type declarations fail
	p.parseTypeDecl = |s: State|
		result := origParseTypeDecl(s)
		if result
			return result
		return parseMarkup(s)

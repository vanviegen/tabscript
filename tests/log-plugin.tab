tabscript 1.0

# Logging plugin for TabScript.
# Adds @log prefix to variable declarations to automatically log function calls.
#
# Usage in header:
#   tabscript 1.0 plugin=log-plugin.tab
#
# Syntax:
#   @log myFunc := |x: number| x * 2
#   Transpiles to: const myFunc = (x: number) => { console.log('myFunc', x); return x * 2; }
#
# @module plugins/log

import type {Parser, State, Register, Options, PluginOptions} from "tabscript"

# Create the logging plugin parser extensions.
export default function createLogPlugin|register: Register, pluginOptions: PluginOptions, globalOptions: Options|
	IDENTIFIER := /[a-zA-Z_$][0-9a-zA-Z_$]*/y

	# Parse @log prefix before variable declarations
	parseLogDecl := |p: Parser, s: State|
		if !s.read& '@log'
			return false

		# Get the variable name
		name := s.must& s.read& IDENTIFIER
		s.must& s.read& ':'

		isLet := !!s.read& ':'
		s.emit& (isLet ? 'let ' : 'const ') + name

		# Parse the type annotation if present
		snap := s.snapshot()
		if !globalOptions.js
			s.emit& ':'
		if !p.parseType(s)
			snap.revertOutput()

		# Must have assignment
		s.must& s.read& '='

		# Check if it's a function
		if s.peek& '|'
			# It's a function - wrap with logging
			s.emit& '=('
			s.must& p.parseFuncParams(s)
			s.emit& '=>{console.log(' + JSON.stringify(name) + ',...arguments);'
			
			# Try to parse a block, otherwise parse single expression with return
			if !s.parseGroup& {jsOpen: '', jsClose: '', next: ';', jsNext: null, allowImplicit: true} || s.recoverErrors& || p.parseStatement(s)
				s.emit& 'return('
				s.must& p.parseExpression(s)
				s.emit& ');'
			s.emit& '})'
		else
			# Not a function - just log the initial value
			s.emit& '=(()=>{const _v='
			s.must& p.parseExpression(s)
			s.emit& ';console.log(' + JSON.stringify(name) + ',_v);return _v;})()'

		return true

	# Register to run before parseStatement to catch @log declarations
	register.before& 'parseStatement' parseLogDecl

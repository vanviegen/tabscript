tabscript 1.0

# test

import
	greet as getGreeting
	answer
from './typescript'

import {ask as getQuestion, question} from './tabscript'

import * as E from './tabscript'

x : number = 3
xx :: string or undefined = undefined
xx = "test"
y := "str"

function a||
	return 5

async function a2
	return await 5

function b1|arg: any, x: number or Something| : number
	return 5

function b2|
	arg: any
	x: number or Something
| : number
	return 5

function b3|
	arg: any
	x: number or Something
|
	return 5

num :: 3 or 4 = 3
if num == 3
	num = 4

function assert|val: any|: asserts val
	if !val
		throw new Error("Value is not a string");

# Strict equality checking by default
three := Math.random() < 0.5 ? '3' : 3
assert.. three =~ 3 # =~ translates to ==, !~ to != (always true)
assert.. three != 3 # == translates to ===, != to !== (false in half the cases)

n ::= 0
if n > 3 n++

done := |a: number, b: number|: boolean
	return a + b > 5

proceed := ||; # empty function
rescue := ||;
halt := ||;

if done(n, 2) proceed()

if done(n, 2)
	proceed()

if done.. n 2
	proceed()

if (done.. n 2) proceed()

if done..
	n
	2
; # the semicolon separates the function call args from the if-body
	proceed()
else if (done.. n n)
	rescue.. # call without args
else
	halt()

data ::= [] as any

x2 ::= {3: 4} as any
sta := {a: 1, b: 2, c: {d: 3, [x2]: {f: 4}}}
sto := {
	a: 1
	b: 2, # optional comma
	c: {
		d: 3
		[x2]: {f: 4}
	}
}

type x =
	z: number
	x: (|arg1:number, arg2:string| : number) or string
	g: number or string
	a: |x: any| : number
	b: |x:number| : void or string
	c: || : void

(data[3]?.test as any)!.a++ + (4 as number)

str : string = "test"

type myFunc = |a: number, b: number| : number or string



arr :: number[] or undefined
sa : [number, string] = [3, "test"]

arr?.[1] as number and {test: number}
arr![1]

lala := <T>|| : T
	return {} as T

lala2 := <T>|| {} as T # Should be able to return literal objects

# Signature overloading
function sdf|t: '3' or {x: number}| : void
function sdf|a: number, b: number| : number
function sdf|a: any, b?: any|
	return 123

sdf({x:42})
sdf.. {x:42}
sdf.. '3'
sdf.. 5, 8

select := |t: 'a' or 'b' or 3| 'x'+t
select(3)

lala3 := <T extends Record<string, number>>|x: T| : T
	return {} as T

rest := |...args: number[]|
	return args.reduce(|a, b| a + b)

i :: any = 3
i = i=3, i==4

for x: in arr console.log.. x
for x2: of arr or [] console.log.. x2

for i=0 i<10 i++ console.log.. i
for i::=0; i<10; i++; console.log.. i

abstract class X<T extends Record<number,any>> extends Array<T>
	arg: number = 123
	constructor|...args: T[]| super(...args)
	method|| : void ;
	abstract abstractMethod|| : void
	get length|| : number
		return super.length

interface Something extends X<Record<number, string>>
	a: number
	b: string
	c|| : void

XXXX := class name<S, T>
	constructor|| {} # return a literal object

new XXXX<number,string>()

text := `This ${sdf.. 2 ('3' as any as number)} ${`works`}`

enum E2
	A
	B = 42
	C

enum E3 {A, B = 42, C}

enum Direction
	Up,
	Down,
	Left,
	Right,

day:number = 1
switch day
	1
		console.log("It is a Monday.")
	0+a() as any
		console.log("It is a Sunday.")
	*: console.log("It's a day")
	2 console.log("It is a Tuesday.")

function templatedFunc<A>||: A or A[]
	return []

# templated args:
templatedFunc<number or string>
templatedFunc<number or string>()

weirdFunc := <T>|x: number|
	return <A>||
		return new Date

date := weirdFunc<number or string>(x)<Something>()

# two comparisons:
(3 + 4) < num or x > 2

test := |str: TemplateStringsArray, ...args: any[]|
	console.log.. str.join(", ") args.join(", ")
	return |arg: number|
		console.log.. arg

test`string ${x as number} ${3+4}`

test`string`(x)

# Binary logic

result := x %bit_xor num %bit_and 42 %bit_or %bit_not 123 %shift_left 2

isSet := x?

type Handler = |event: Event|: void
type Mapper<T, U> = |input: T|: U
